1. 实现算法的两种技术：递归法和迭代法

2. 两种遍历二叉树的策略：层序遍历（BFS）和深度优先遍历(DFS)
递归和迭代都可以实现DFS或BFS。

代码风格统一：（为什么要统一风格？因为有助于规避奇怪的问题，统一细节和思路，提高准确率）
1. 函数命名习惯：二叉树中用遍历思路解题时函数签名一般是 void traverse(...)，没有返回值，靠更新外部变量来计算结果，而用分解问题思路解题时函数名根据该函数具体功能而定，而且一般会有返回值，返回值是子问题的计算结果。

与此对应的，你会发现我在 
回溯算法核心框架 中给出的函数签名一般也是没有返回值的 void backtrack(...)，而在 
动态规划核心框架 中给出的函数签名是带有返回值的 dp 函数。这也说明它俩和二叉树之间千丝万缕的联系。

2. 什么时候用类属性self.？
只有当在递归中需要贡献状态的时候才写self. 比如最大值最小值，需要在递归中持续存储并且持续比较
这里很好的优化例子就是530题，代码随想录用的类属性来存储的pre，但是其实没有必要，直接递归传递就可以 


![alt text](image.png)
前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点，绝不仅仅是三个顺序不同的 List：

前序位置的代码在刚刚进入一个二叉树节点的时候执行；

后序位置的代码在将要离开一个二叉树节点的时候执行；

中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。
二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

def traverse(root):
    if root is None:
        return
    # 前序位置
    traverse(root.left)
    # 中序位置
    traverse(root.right)
    # 后序位置

3. 遍历和分治
综上，遇到一道二叉树的题目时的通用思考过程是：

1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现。

2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。

3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。

4. 前中后序位置
中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。

仔细观察，前中后序位置的代码，能力依次增强。

前序位置的代码只能从函数参数中获取父节点传递来的数据。

中序位置![alt text](image.png)的代码不仅可以获取参数数据，还可以获取到左子树通过函数返回值传递回来的数据。

后序位置的代码最强，不仅可以获取参数数据，还可以同时获取到左右子树通过函数返回值传递回来的数据。

所以，某些情况下把代码移到后序位置效率最高；有些事情，只有后序位置的代码能做。

5. 我自己总结的二叉树算法思路 2025/2/10
  我自己的风格：先判断是否需要返回值（不需要就是traverse能解决，需要就是分治法），再判断需要什么递归顺序（前中后）（这一点决定了中的处理逻辑放在哪里），然后考虑最后一次终止条件  中间和最后的终止条件