典型的“在某个区间里找到第一个满足某个条件的位置”的问题 —— 而只要这个“条件”具有单调性（即前面不满足，后面满足，或者反过来），我们就可以用二分查找来高效地找这个位置。

二分法的termination condition

🧠 【通用三步法】判断如何写二分查找
步骤 1：你是在找 值 还是 位置？
找某个具体的值是否存在 ⇒ 通常 while left <= right

找最小/最大满足条件的“下标”或值 ⇒ 推荐 while left < right

步骤 2：mid 满足条件时，你要往 左 还是往 右？
如果条件成立时要往左：right = mid 或 right = mid - 1

如果条件成立时要往右：left = mid + 1

🔁 如果你是在找「最小满足条件」的位置，通常是：

python
复制
编辑
if check(mid):
    right = mid
else:
    left = mid + 1
步骤 3：你是否要保留 mid？
保留 mid：用 right = mid

不保留 mid：用 right = mid - 1



学习路径：
| 阶段 | 类别         | 题型关键词         | 例题编号（LeetCode）       |
| -- | ---------- | ------------- | -------------------- |
| 1  | 🔍 查找具体值   | 普通二分查找        | LeetCode 704         |
| 2  | ✅ 找左边界     | 第一个 ≥ target  | LeetCode 35, 300（辅助） |
| 3  | ✅ 找右边界     | 最后一个 ≤ target | LeetCode 34（变形）      |
| 4  | 📈 单调函数找值  | 最小满足条件的解      | LeetCode 875、1011    |
| 5  | 🏔️ 山型数组峰值 | 峰值、局部极大       | LeetCode 852, 162    |
| 6  | 📦 难度提升    | 二分答案 + 贪心/前缀和 | LeetCode 410、1201    |


保留mid且left == mid的时候，mid必须偏右，（4+4）和（4+5）//2的结果相同，所以可能出现死循环，无法前进缩小范围
❌ while left <= right 中，mid 是有可能等于 right 的，如果你在里面写 right = mid，那就完全没变！==> 死循环


🎯 总结：
写法	有无死循环风险	是否推荐
right = mid	✅ 有死循环风险	❌ 不推荐，除非 mid > left 可保证
right = mid - 1	❌ 安全	✅ 推荐
while left < right + right = mid	❌ 安全	✅ 强烈推荐
left = mid 有很大风险！！


几大问题：
1. 什么时候用while left<=right, left < right?
2. 什么时候需要用res来记录mid 什么时候直接用left right来记录
3. 什么时候left = mid会出现死循环什么时候不会


<= 左闭右闭 mid可能等于right
<  左闭右开 mid == right永远不可能，以及只能取到right -1