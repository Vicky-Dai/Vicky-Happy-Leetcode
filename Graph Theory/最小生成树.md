1. 最小生成树是什么
最小生成树是（无向有权图）所有节点的最小联通子图，即以最小的成本（边权值）将图中所有节点链接到一起
图中有n个节点，那么一定可以用n-1条边将所有节点连接到一起，那么如何选择这n-1条边就是最小生成树算法的任务所在。

2. 最小生成树的算法--prim算法
prim算法是从节点的角度采用贪心的策略每次寻找距离最小生成树最近的节点并加入到最小生成树中。
prim三部曲：
第一步，选距离生成树最近节点
第二步，最近节点加入生成树
第三步，更新非生成树节点到生成树的距离（即更新minDist数组）
minDist数组是prim算法的灵魂，它帮助prim算法完成最重要的一步，就是如何找到距离最小生成树最近的点。minDist数组里记录的其实也是最小生成树的边的权值。minDist数组用来记录每一个节点距离最小生成树的最近距离。

prim维护的数据：
graph:维护节点的图 10001 v+1
minDist: 用于节点距离最小生成树的距离 v+1
inTree: 用于记录节点是不是在数组内 v+1


拓展了如何获得最小生成树的每一条边，其实添加的代码很简单，主要是理解为什么使用parent数组来记录边:方便知道每次取的最短是谁和谁连接的。以及在哪里更新parent数组：在第三步，因为只有第三步接触了minDist数组，知道是谁到谁。

同时，因为使用一维数组，数组的下标和数组如何赋值很重要，不要搞反，导致结果被覆盖。

*时间复杂度为O(n^2)，其中n为节点数量。

3. 最小生成树算法--kruskal算法
prim 算法是维护节点的集合，而 Kruskal 是维护边的集合。
kruscal的思路：

第一步，边的权值排序，因为要优先选最小的边加入到生成树里
第二步，遍历排序后的边
如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环 (并查集)
如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合

*时间复杂度：nlogn （快排） + logn （并查集） ，所以最后依然是 nlogn 。n为边的数量。



最小生成树（Minimum Spanning Tree, MST）和最短路算法（Shortest Path Algorithm）虽然都处理图（Graph）结构中的路径问题，但它们的目的、适用场景、结果形式是完全不同的。下面从多个维度来对比这两类算法：

🔍 1. 目的不同
项目	最小生成树 (MST)	最短路算法
目标	找到连接图中所有顶点的最小代价树	找到从一个起点到一个或多个点的最短路径
优化对象	所有边的总权值最小的生成树	从起点到终点的路径长度最小
连接情况	保证所有节点都连通（生成一个树）	只关注起点到其他节点的最短路径

🧭 2. 适用场景不同
项目	最小生成树	最短路径
网络布线、管道、道路等低成本连接所有点	✅	❌
地图导航、路由规划、传输时延最短等问题	❌	✅

⚙️ 3. 算法输出不同
项目	最小生成树	最短路径算法
输出结构	一棵树（n 个节点，n-1 条边）	每个节点的最短路径（可能多条路径）
路径覆盖	没有指定起点终点，是整个图的覆盖结构	从指定起点出发，覆盖到其他所有或指定节点

🧮 4. 常见算法
类别	常见算法
最小生成树	Kruskal、Prim、Borůvka
最短路径	Dijkstra、Bellman-Ford、Floyd、A*