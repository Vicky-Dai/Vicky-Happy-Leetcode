dijkstra算法：在有权图（权值非负数）中求从起点到其他节点的最短路径算法。(可以同时求 起点到所有节点的最短路径)

dijkstra 算法 同样是贪心的思路，不断寻找距离 源点最近的没有访问过的节点。
核心minDist数组：表示源点到节点的最短距离

1. 朴素版dijkstra
dijkstra三部曲：

第一步，选源点到哪个节点近且该节点未被访问过
第二步，该最近节点被标记访问过
第三步，更新非访问节点到源点的距离（即更新minDist数组）
时间复杂度为 O(n^2)，可以看出时间复杂度 只和 n （节点数量）有关系


这么在n 很大的时候，也有另一个思考维度，即：从边的数量出发。
2. 堆优化版dijkstra
其实思路依然是 dijkstra 三部曲：

第一步，选源点到哪个节点近且该节点未被访问过
我们要选择距离源点近的节点（即：该边的权值最小），所以 我们需要一个 小顶堆 来帮我们对边的权值排序，每次从小顶堆堆顶 取边就是权值最小的边。（未访问过的节点，不会加到堆里进行排序）
第二步，该最近节点被标记访问过
第三步，更新非访问节点到源点的距离（即更新minDist数组）

时间复杂度：O(ElogE) E 为边的数量  （添加，弹出） 复杂度分析见https://github.com/youngyangyang04/leetcode-master/blob/master/problems/kamacoder/0047.%E5%8F%82%E4%BC%9Adijkstra%E5%A0%86.md
空间复杂度：O(N + E) N 为节点的数量 

和朴素版主要区别：
邻接表的表示方式不同
使用优先级队列（小顶堆）来对新链接的边排序


Add On:
1. 我们在搜索最短路的时候， 如果是无权图（边的权值都是1） 那就用广搜，代码简洁，时间效率和 dijkstra 差不多 （具体要取决于图的稠密）

2. 如果是有权图（边有不同的权值），优先考虑 dijkstra。


3. 对于负权节点的处理？ prim可以handle，但是dijkstra不行
本质上：在权值全是正整数时，Dijkstra 算法能保证某个点一旦出堆（被“锁定”），它的距离就是最短的？为什么有负权值时这个保证就失效？
✅ 一句话解释 Dijkstra 的核心原理：
在图中只要边权都是正的，那么从源点出发，越早被访问的点，它的路径一定越短。
这背后是因为：
正权保证路径越走越远，永远不会出现“后来绕路反而更近”的情况。

🔍 用直觉类比：走路距离
✅ 正边权值（比如马路的距离都 ≥ 1）
假设你从家出发（源点），每条路都有距离：
家 → A = 3 米
家 → B = 5 米
A → B = 4 米
你最开始看：家 → B 是 5 米
但家 → A → B 是 3 + 4 = 7 米
B 被第一次访问（5米）时，已经是最短的，因为以后任何路径都只能更远。
❌ 负边权：马路长度可以是“负的”？
假如：A → B = -4 米
那家 → A → B = 3 + (-4) = 1 米
比直接家 → B = 5 米短很多！
这就说明：本来以为 B 最短是 5，后来发现还有更短的！
这就是 Dijkstra 彻底失败的时刻——它已经把 B 锁定成 5，不会再更新成 1。
https://www.bilibili.com/video/BV1q15DzREAj?spm_id_from=333.788.player.player_end_recommend_autoplay&vd_source=407b3b0f8f7f8cca1415caa67eb528ad
https://www.bilibili.com/video/BV1PK411e7zQ/?spm_id_from=333.337.search-card.all.click&vd_source=407b3b0f8f7f8cca1415caa67eb528ad