dijkstra算法：在有权图（权值非负数）中求从起点到其他节点的最短路径算法。(可以同时求 起点到所有节点的最短路径)

dijkstra 算法 同样是贪心的思路，不断寻找距离 源点最近的没有访问过的节点。
核心minDist数组：表示源点到节点的最短距离

1. 朴素版dijkstra
dijkstra三部曲：

第一步，选源点到哪个节点近且该节点未被访问过
第二步，该最近节点被标记访问过
第三步，更新非访问节点到源点的距离（即更新minDist数组）
时间复杂度为 O(n^2)，可以看出时间复杂度 只和 n （节点数量）有关系


这么在n 很大的时候，也有另一个思考维度，即：从边的数量出发。
2. 堆优化版dijkstra
其实思路依然是 dijkstra 三部曲：

第一步，选源点到哪个节点近且该节点未被访问过
我们要选择距离源点近的节点（即：该边的权值最小），所以 我们需要一个 小顶堆 来帮我们对边的权值排序，每次从小顶堆堆顶 取边就是权值最小的边。（未访问过的节点，不会加到堆里进行排序）
第二步，该最近节点被标记访问过
第三步，更新非访问节点到源点的距离（即更新minDist数组）

时间复杂度：O(ElogE) E 为边的数量  （添加，弹出） 复杂度分析见https://github.com/youngyangyang04/leetcode-master/blob/master/problems/kamacoder/0047.%E5%8F%82%E4%BC%9Adijkstra%E5%A0%86.md
空间复杂度：O(N + E) N 为节点的数量 

和朴素版主要区别：
邻接表的表示方式不同
使用优先级队列（小顶堆）来对新链接的边排序


Add On:
 我们在搜索最短路的时候， 如果是无权图（边的权值都是1） 那就用广搜，代码简洁，时间效率和 dijkstra 差不多 （具体要取决于图的稠密）

如果是有权图（边有不同的权值），优先考虑 dijkstra。