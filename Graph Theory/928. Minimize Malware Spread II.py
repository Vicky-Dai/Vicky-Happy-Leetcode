class Solution:
    def minMalwareSpread(self, graph, initial):
        n = len(graph)
        infected = set(initial)
        initial.sort()

        # 每个感染源对应它独占能感染的“干净节点”列表
        src_to_clean = {src: [] for src in initial}

        # DFS：从 clean node 出发，逆向探索能连到哪些感染源
        def dfs(node, visited, sources):
            visited.add(node)

            # 如果遇到感染源，加入 sources，然后停止对这个路径的继续探索
            if node in infected:
                sources.add(node)
                return

            # 否则继续往外 DFS
            for nei in range(n):
                if graph[node][nei] == 1 and nei not in visited:
                    dfs(nei, visited, sources)

        # 对每个干净节点进行 DFS
        for i in range(n):
            if i not in infected:  # 仅 clean 节点才需要 DFS
                visited = set()
                sources = set()
                dfs(i, visited, sources)

                # 如果只有一个感染源能触达这个 clean 节点
                if len(sources) == 1:
                    src = next(iter(sources))
                    src_to_clean[src].append(i)

        # 计算哪个感染源拥有最多的“独占可感染节点”
        best_src = initial[0]
        best_val = -1

        for src in initial:
            count = len(src_to_clean[src])
            if count > best_val or (count == best_val and src < best_src):
                best_val = count
                best_src = src

        return best_src


class Solution:
    # the key observation for me is the fact that we don't need to
    # really delete the initial in the graph. We can simply ignore
    # the deleted initial while we are doing BFS. So basically we
    # do BFS with each deleted value on initial, and we get the
    # minimal count of the connected graph. Note if two deleted
    # values give same count of connected graph, then we choose
    # smaller value. that's why I used a tuple, (BFS(a), a) this 
    # will first compare BFS(a), if they are equal then it compares
    # a.
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        def BFS(delval):
            seen, lst = set(), list(initial)
            while lst:
                node = lst.pop()
                if node == delval or node in seen: continue
                seen.add(node)
                lst += [i for i, val in enumerate(graph[node]) if val]
            return len(seen)
        return min(initial, key=lambda a: (BFS(a), a))
            
# Union Find
class DSU:
    def __init__(self, N):
        self.p = range(N)
        self.sz = [1] * N

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, x, y):
        xr = self.find(x)
        yr = self.find(y)
        self.p[xr] = yr
        self.sz[yr] += self.sz[xr]

    def size(self, x):
        return self.sz[self.find(x)]


class Solution(object):
    def minMalwareSpread(self, graph, initial):
        N = len(graph)
        initial_set = set(initial)
        clean = [x for x in range(N) if x not in initial_set]

        # clean[u] == 1 if its a node in the graph not in initial.
        dsu = DSU(N)
        for u in clean:
            for v in clean:
                if graph[u][v]:
                    dsu.union(u, v)

        # dsu now represents the components of the graph without
        # any nodes from initial.  Let's call this graph G.
        count = collections.Counter() # it records the number of nodes in each component
        node_to_compo = {} # it records the components that each node in initial can reach
        for u in initial:
            components = set()
            for v in clean:
                if graph[u][v]:
                    components.add(dsu.find(v))
            node_to_compo[u] = components

            for c in components:
                count[c] += 1 

        # For each node u in initial, nodeToCompo.get(u)
        # now has every component from G that u neighbors.

        best = (-1, None) # score, node
        for u, components in node_to_compo.items(): # u is the node in initial, components is the components that the node u can reach in the set
            score = 0
            for c in components: # for loop through all the components that the node u can reach in the set
                if count[c] == 1: #uniquely infected
                    score += dsu.size(c)
            if score > best[0] or score == best[0] and u < best[1]:
                best = (score, u)

        return best[1]