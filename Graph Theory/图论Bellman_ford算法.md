1. Benllman_ford解决经典的带负权值的单源最短路问题
Bellman_ford算法的核心思想是 对所有边进行松弛n-1次操作（n为节点数量），从而求得目标最短路。

- 松弛是什么？
如果 通过 A 到 B 这条边可以获得更短的到达B节点的路径，即如果 minDist[B] > minDist[A] + value，那么我们就更新 minDist[B] = minDist[A] + value ，这个过程就叫做 “松弛” 。

minDist[B] = min(minDist[A] + value, minDist[B]) 

- 时间复杂度 O(N * E)  N 为节点数量，E为边的数量

2. Bellman_ford队列优化算法 SPFA算法（shortest path faster algorithm）
用队列来记录之前更新过的节点，依据队列对边进行松弛（因为原先会把所有边都松弛一遍，有一些是没有意义的）

- 时间复杂度
图越稀疏，SPFA的效率就越高。
一般来说，SPFA 的时间复杂度为 O(K * N) K 为不定值，因为 节点需要计入几次队列取决于 图的稠密度。
如果图是一条线形图且单向的话，每个节点的入度为1，那么只需要加入一次队列，这样时间复杂度就是 O(N)。
所以 SPFA 在最坏的情况下是 O(N * E)，但 一般情况下 时间复杂度为 O(K * N)。


Add on 概念：
正权回路 就是有环，但环的总权值为正数。

3. Bellman_ford 算法在负权回路的应用
BF算法的核心就是松弛n-1次，就可以求得起点到任何节点的最短路径，n次及以上就没有任何变化了，（抽象象形理解为一个弹簧压缩到最短，就无法再压缩了，实际上代码的实现就是，再次层新因为回路为正，所以反而会数值变大，所以保持第n-1次不变。）所以解决负权回路的 核心思路，就是在 kama94.城市间货物运输I 的基础上，再多松弛一次，看minDist数组 是否发生变化。

如果是BF优化版的SPFA ,那么如果节点加入队列的次数 超过了 n-1次 ，那么该图就一定有负权回路。
