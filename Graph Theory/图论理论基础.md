一、图论理论基础
1. 图的种类: 无向图、有向图；加权图
2. 度：无向图中连接该点的边数
3. 出度和入度：从该节点出发的边的个数；指向该节点边的个数
4. 连通性：
   - 连通图：无向图中任何两个节点都是可以到达的； 非连通图：若有节点不能到达其他节点
   - 强连通图：在有向图中，任何两个节点是可以相互到达的 （注意要是相互！）
   - 连通分量：无向图中的极大连通子图称为该图的一个连通分量（注意是极大！任意一个子图是不行的，必须把子图扩展到最大）
   - 强联通分量：有向图中极大强连通子图

二、图的代码表示
一般使用邻接表、邻接矩阵 或者用类来表示。
主要是 朴素存储、邻接表和邻接矩阵。
1. 邻接矩阵
    用二维数组来表示图解构， 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。
    例如： grid[2][5] = 6，表示 节点 2 连接 节点5 为有向图，节点2 指向 节点5，边的权值为6。
    如果想表示无向图，即：grid[2][5] = 6，grid[5][2] = 6，表示节点2 与 节点5 相互连通，权值为6。
 - 优点：简单、任意两个顶点之间是否存在边的操作非常快、适合稠密图（边数接近顶点数平方）
 - 缺点：时间空间浪费。不适合稀疏图（点多边少），申请过大二维数组造成空间浪费，且遍历边需要遍历整个数组，时间浪费

2. 邻接表 
    实现方式：数组+链表的方式；数组+数组的方式（二维数组）
    原理：从边的角度来表示图，有多少边申请对应大小链表，有多少边 邻接表才会申请多少个对应的链表节点。
    ![alt text](image.png) 这里数组存放每个节点，保存每个节点的头指针，指向的链表通常没有顺序，但是要包含该点出发的所有边
 - 优点：只需要存储边空间利用率高，遍历节点连接情况相对容易 
 - 缺点：检查两个点之间是否存在变效率相对较低，需要 O(V)时间，V表示某节点连接其他节点的数量；实现难理解

 3. 简单的list 见kama109
 具体解释见附录（下面）


三、遍历方式：深度优先搜索dfs和广度优先搜索bfs
深度优先搜索（dfs），就不得不说和广度优先搜索（bfs）有什么区别
dfs是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。
bfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。

复杂度：
1. 时间复杂度
邻接表：查找所有顶点的邻接点所需时间为O(E)，放稳定点的临界点所花时间为O(V), 总的时间复杂度为O(E+V) = O(n)
邻接矩阵：查找每个顶点的邻接点所需时间为O(v), 要查找整个矩阵，总的时间度为O(v^2).
V为图的顶点数，E为边数

深搜三部曲：
1. 确认递归函数，参数
void dfs(参数)

2. 确认终止条件
if (终止条件) {
    存放结果;
    return;
}

3. 处理目前搜索节点出发的路径
for (选择：本节点所连接的其他节点) {
    处理节点;
    dfs(图，选择的节点); // 递归
    回溯，撤销处理结果
}

广度优先搜索(bfs)，是以起始点为中心一圈一圈进行搜索，一旦遇到中点，记录之前走过的节点就是一条最短路，适合解决最低按路径问题。
容器：队列 栈 数组 都可以
process video: https://www.youtube.com/watch?v=oDqjPvD54Ss
coding模板：
from collections import deque

# 方向数组，表示四个方向：右、下、左、上
dir = [(0, 1), (1, 0), (-1, 0), (0, -1)]

def bfs(grid, visited, x, y):
    # 创建队列并加入起始节点
    que = deque([(x, y)])  #定义队列并加入起始节点
    visited[x][y] = True  # 立刻标记起始节点为访问过
    
    while que:
        curx, cury = que.popleft()  # 从队列中取出当前节点的坐标
        # 遍历当前节点的四个方向
        for dx, dy in dir: // 开始向当前节点的四个方向左右上下去遍历
            nextx, nexty = curx + dx, cury + dy  # 获取周围节点的坐标
            # 检查是否越界
            if nextx < 0 or nextx >= len(grid) or nexty < 0 or nexty >= len(grid[0]):
                continue
            # 如果没有访问过该节点，则加入队列并标记为已访问
            if not visited[nextx][nexty]:
                que.append((nextx, nexty))
                visited[nextx][nexty] = True



我自己的一些思考：
## 1. 并不是所有图题都要建图？
是的，比如kama110这类题中，图的边是隐式定义的，只要你能根据某种规则判断两个节点是否相连（例如 judge 函数），就可以在遍历时“动态地”判断邻接关系，而无需预先建图。

❓那什么时候一定要建邻接表/邻接矩阵？
图结构固定并复杂： 比如输入是明确的边（如“a与b有边”），而不是用规则判断的。

边会被重复访问多次： 如果你要多次查找某个节点的所有邻接点。

更高效的访问要求： 例如稠密图中查找所有邻接点，邻接矩阵更快；稀疏图中用邻接表更节省空间。

## 2. 是否所有图题建图都要邻接表邻接矩阵？
    并不是
    何时需要用邻接矩阵或邻接表？
    1. 需要快速查询某两个节点之间是否有边
    邻接矩阵：

    优点：可以在O(1)时间内判断两个节点是否直接相连（即判断matrix[u][v]是否存在边）。
    适用场景：当你需要频繁判断边是否存在时。
    邻接表：

    优点：通过维护每个节点的邻接边链表，可以在平均O(out-degree)时间快速获得某个节点的后继节点。
    缺点：不能直接判断两个节点之间是否有边（除非遍历邻接表）。
    适用场景：当你需要迅速访问某个节点的邻接边（后继节点）。
    2. 边的操作（插入、删除）频繁
    邻接表：

    插入：O(1)（在链表头插入）
    删除：O(out-degree)（找出对应边然后删除）
    如果频繁删除边，邻接表更高效。
    邻接矩阵：

    插入/删除边：O(1)，只需修改矩阵元素。
    3. 进行复杂的图遍历
    邻接表：

    遍历所有邻接边（后继）效率高，更适合深度优先搜索（DFS）或广度优先搜索（BFS）。
    邻接矩阵：

    遍历邻接节点时，需要扫描一行，时间复杂度为O(n)，在稠密图中性能较差。
    4. 稀疏图与稠密图
    稀疏图（边远少于顶点平方）：

    使用邻接表，节省空间，遍历快速。
    稠密图（接近顶点数的平方的边数）：

    使用邻接矩阵，判断边存在性快。
    5. 需要多次临时修改边的值
    邻接矩阵：

    修改边权或状态非常方便，花费空间，但操作简单。
    邻接表：

    需要更复杂的操作（增加/删除边）时，维护较复杂。

## 3. prim kruskal dijkstra(朴素 堆) bellman_ford 区别和联系
首先prim kruskal是解决，最小连通图，并且可以接受负值，前者从节点角度，后者从边角度，贪心算法
其次，dijkstra解决的是，从起点到终点的对最短路，无法解决负权值，贪心算法，堆实现用最小堆，是有顺序的
最后，bellman_ford解决的是负权值单源最短路，同时还有一点动态规划的思想。SPFA可以通过队列的方式只去更新新的路径相连的路径。其次，还能处理负权回路问题。
重点是松弛：if dist[u] + weight(u, v) < dist[v]:
    dist[v] = dist[u] + weight(u, v)
