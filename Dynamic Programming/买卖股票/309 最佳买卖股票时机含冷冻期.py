#由122延伸出来，同样可以买卖多次，但是这次卖出之后要冷冻一天
#这就导致了冷冻那天的状态，前一天必须卖出，当前不能动，后面才可再次买入，对状态有了具体的要求，所以就必须设置特殊状态 (而冷冻期的前一天，只能是 「今天卖出股票」状态，如果是 「不持有股票状态」那么就很模糊，因为不一定是 卖出股票的操作。)
#补充：有人说冷冻期只有一天的情况下，可以用打家劫舍的思路压缩成两个？？？ 这个不太懂
#dp[i][0]持有股票 dp[i][1]保持卖出 dp[i][2]卖出股票 dp[i][3]冷冻期

#四个变量的版本
class Solution:
    def maxProfit(self, prices:list[int]) -> int:
        n = len(prices)
        if n == 0:
            return 0
        dp = [[0]*4 for _ in range(n)]
        dp[0][0] = - prices[0]
        for i in range(1, n):
            dp[i][0] = max(dp[i-1][0], max(dp[i-1][3], dp[i-1][1]) - prices[i])  # 当前持有股票的最大利润等于前一天持有股票的最大利润或者前一天不持有股票且不处于冷冻期的最大利润减去当前股票的价格
            dp[i][1] = max(dp[i-1][1], dp[i-1][3])  # 当前不持有股票且处于冷冻期的最大利润等于前一天持有股票的最大利润加上当前股票的价格
            dp[i][2] = dp[i-1][0] + prices[i]  # 当前不持有股票且不处于冷冻期的最大利润等于前一天不持有股票的最大利润或者前一天处于冷冻期的最大利润
            dp[i][3] = dp[i-1][2]  # 当前不持有股票且当天卖出后处于冷冻期的最大利润等于前一天不持有股票且不处于冷冻期的最大利润
        return max(dp[n-1][3], dp[n-1][1], dp[n-1][2])  # 返回最后一天不持有股票的最大利润
    

#dp[i][0]比较难理解里面那个max prices = [1, 2, 3, 0, 2, 4] 这是一个很好的例子，解释什么时候保持卖出比冷静期大，究其原因是因为有的时候如果价格突然在上一天下降，如果在冷静期就必须卖出，而如果在保持卖出的状态，就可以等待更好的价格