#由122延伸出来，同样可以买卖多次，但是这次卖出之后要冷冻一天
#这就导致了冷冻那天的状态，前一天必须卖出，当前不能动，后面才可再次买入，对状态有了具体的要求，所以就必须设置特殊状态 (而冷冻期的前一天，只能是 「今天卖出股票」状态，如果是 「不持有股票状态」那么就很模糊，因为不一定是 卖出股票的操作。)
#补充：有人说冷冻期只有一天的情况下，可以用打家劫舍的思路压缩成两个？？？ 这个不太懂
#dp[i][0]持有股票 dp[i][1]保持卖出 dp[i][2]卖出股票 dp[i][3]冷冻期

#四个变量的版本
class Solution:
    def maxProfit(self, prices:list[int]) -> int:
        n = len(prices)
        if n == 0:
            return 0
        dp = [[0]*4 for _ in range(n)]
        dp[0][0] = - prices[0]
        for i in range(1, n):
            dp[i][0] = max(dp[i-1][0], max(dp[i-1][3], dp[i-1][1]) - prices[i])  # 当前持有股票的最大利润等于前一天持有股票的最大利润或者前一天不持有股票且不处于冷冻期的最大利润减去当前股票的价格
            dp[i][1] = max(dp[i-1][1], dp[i-1][3])  # 当前不持有股票且处于冷冻期的最大利润等于前一天持有股票的最大利润加上当前股票的价格
            dp[i][2] = dp[i-1][0] + prices[i]  # 当前不持有股票且不处于冷冻期的最大利润等于前一天不持有股票的最大利润或者前一天处于冷冻期的最大利润
            dp[i][3] = dp[i-1][2]  # 当前不持有股票且当天卖出后处于冷冻期的最大利润等于前一天不持有股票且不处于冷冻期的最大利润
        return max(dp[n-1][3], dp[n-1][1], dp[n-1][2])  # 返回最后一天不持有股票的最大利润
    

#dp[i][0]比较难理解里面那个max prices = [1, 2, 3, 0, 2, 4] 这是一个很好的例子，解释什么时候保持卖出比冷静期大，究其原因是因为有的时候如果价格突然在上一天下降，如果在冷静期就必须卖出，而如果在保持卖出的状态，就可以等待更好的价格

# 假设有以下股票价格：
prices = [1, 2, 3, 0, 2, 4]
# 我们来详细计算一下 dp 数组的值，并解释每一步的状态转移。

# 初始化
# 在第 0 天（即 i = 0），我们有以下初始化：
# dp[0][0] = -prices[0]  # 第 0 天持有股票的最大利润是负的股票价格
# dp[0][1] = 0           # 第 0 天不持有股票且不在冷冻期的最大利润是 0
# dp[0][2] = 0           # 第 0 天卖出股票的最大利润是 0
# dp[0][3] = 0           # 第 0 天不持有股票且在冷冻期的最大利润是 0
# # 状态转移
# # 从第 1 天开始，我们根据前一天的状态来更新当前的状态：

# # 第 1 天
# dp[1][0] = max(dp[0][0], max(dp[0][3], dp[0][1]) - prices[1])
#          = max(-1, max(0, 0) - 2)
#          = max(-1, -2)
#          = -1

# dp[1][1] = max(dp[0][1], dp[0][3])
#          = max(0, 0)
#          = 0

# dp[1][2] = dp[0][0] + prices[1]
#          = -1 + 2
#          = 1

# dp[1][3] = dp[0][2]
#          = 0
# # 第 2 天
# dp[2][0] = max(dp[1][0], max(dp[1][3], dp[1][1]) - prices[2])
#          = max(-1, max(0, 0) - 3)
#          = max(-1, -3)
#          = -1

# dp[2][1] = max(dp[1][1], dp[1][3])
#          = max(0, 0)
#          = 0

# dp[2][2] = dp[1][0] + prices[2]
#          = -1 + 3
#          = 2

# dp[2][3] = dp[1][2]
#          = 1
# # 第 3 天
# dp[3][0] = max(dp[2][0], max(dp[2][3], dp[2][1]) - prices[3])
#          = max(-1, max(1, 0) - 0)
#          = max(-1, 1)
#          = 1

# dp[3][1] = max(dp[2][1], dp[2][3])
#          = max(0, 1)
#          = 1

# dp[3][2] = dp[2][0] + prices[3]
#          = -1 + 0
#          = -1

# dp[3][3] = dp[2][2]
#          = 2
# # 第 4 天
# dp[4][0] = max(dp[3][0], max(dp[3][3], dp[3][1]) - prices[4])
#          = max(1, max(2, 1) - 2)
#          = max(1, 0)
#          = 1

# dp[4][1] = max(dp[3][1], dp[3][3])
#          = max(1, 2)
#          = 2

# dp[4][2] = dp[3][0] + prices[4]
#          = 1 + 2
#          = 3

# dp[4][3] = dp[3][2]
#          = -1
# # 第 5 天
# dp[5][0] = max(dp[4][0], max(dp[4][3], dp[4][1]) - prices[5])
#          = max(1, max(-1, 2) - 4)
#          = max(1, -2)
#          = 1

# dp[5][1] = max(dp[4][1], dp[4][3])
#          = max(2, -1)
#          = 2

# dp[5][2] = dp[4][0] + prices[5]
#          = 1 + 4
#          = 5

# dp[5][3] = dp[4][2]
#          = 3
# 解释
# 在这个例子中，我们可以看到 dp[i][0] 的计算过程中，max(dp[i-1][3], dp[i-1][1]) 的值在某些情况下确实是保持卖出状态的值较大。具体来说：

# 在第 5 天，dp[4][3] 的值是 -1，而 dp[4][1] 的值是 2，所以 max(dp[4][3], dp[4][1]) 的值是 2。
# 通过这个例子可以看出，max(dp[i-1][3], dp[i-1][1]) 的值取决于前一天的状态，有时保持卖出状态的值较大，有时冷冻期的值较大。这取决于具体的股票价格和交易策略。