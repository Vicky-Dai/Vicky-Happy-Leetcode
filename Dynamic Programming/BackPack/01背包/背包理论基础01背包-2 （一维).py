n, bagweight = map(int, input().split())
weight = list(map(int, input().split()))
value = list(map(int, input().split()))

dp = [0] * (bagweight + 1)  # 创建一个动态规划数组dp，初始值为0

dp[0] = 0  # 初始化dp[0] = 0,背包容量为0，价值最大为0

for i in range(n):  # 应该先遍历物品，如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品  
    for j in range(bagweight, weight[i]-1, -1):  # 倒序遍历背包容量是为了保证物品i只被放入一次  如果一旦正序遍历了，那么物品0就会被重复加入多次！
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

print(dp[bagweight])

#简而言之倒序遍历的原因是：因为滚动数组本质是用下一轮的值覆盖上一轮的值，所以正序遍历会覆盖掉左上角的旧值，只有倒序遍历才能正确拿到左上角的旧值！
#思考：一维数组在二维数组上的改进，其实就是在同一个数组上改值，因为要求的位置的值来自于正上方的，和上方那行左侧的，这就要求了要从后往前遍历，你不能覆盖掉左上的旧值
#先物品再背包：因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。
#这个不是很理解？？？

# 具体示例说明
# 假设我们有一个背包容量 j=5，有两个物品：

# 物品 1：重量 2，价值 3
# 物品 2：重量 3，价值 4
# 使用「先背包容量，后物品」的顺序
# 容量 j=5：

# 先处理物品 1：
# 背包容量为 5，物品 1 的重量是 2，能放入背包。
# 更新 dp[5] = max(dp[5], dp[5-2] + 3)。假设 dp[5] 原先是 0，那么 dp[5] = 3。
# 接着处理物品 2：
# 背包容量为 5，物品 2 的重量是 3，也能放入背包。
# 更新 dp[5] = max(dp[5], dp[5-3] + 4)。此时 dp[5-3] = dp[2] = 0，所以 dp[5] 更新为 4。
# 问题：这里的 dp[5] 只保留了物品 2 的选择状态（价值为 4），覆盖了之前物品 1 的状态。这样，我们最终的 dp[5] 只表示了放入物品 2 的结果，而忽略了组合放入物品 1 和物品 2 的可能性（组合的总价值应该是 3 + 4 = 7）。

# 重点还是在于，因为先确定了只能倒序遍历一维数组，导致如果你先遍历背包，那么其实前侧的值都还没有更新过，那就是初始状态（都是0），所以计算的一定不对
#简而言之，逆序保证了能够使用“上一层”（一维中其实是上一个时空的这个数组）的旧值，先物品在背包保证了之前的旧值存在