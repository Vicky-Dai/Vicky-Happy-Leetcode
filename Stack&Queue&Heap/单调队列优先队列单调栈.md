我自己的总结：
单调队列和单调栈放在一起记：
他们都要保证从（栈/队列）头到（栈/队列）底部保证单调递增/递减
区别是，前者是先进先出，所以要用deque实现，好处是既可以保证动态拿到极端值（最大最小），又可以不断的更新
后者是先进后出，用普通数组实现，好处是可以通过对对碰，找到右边第一个更大或更小的值。也是可以找到凹凸值的方法。
所以：注意如果求最值，就是用单队列，如果是求右边更值，就是单栈



1. 单调队列（Monotonic Queue）
比喻：想象你在一个队伍中，每个人都有一个号码，但你决定根据号码的大小来排队。你想确保每次队伍中的号码都是单调的，即要么是递增的，要么是递减的。

操作：当新来的人（数字）加入队伍时，队伍会“自动调整”，让队伍中的数字保持单调排列。队伍最前面的人总是当前最小或最大的（根据你设定的单调规则）。

应用：就像滑动窗口问题，每次移动窗口，你要确保窗口中的最大值或最小值保持在队列的前面。

比喻总结：单调队列像是一个“自动调整的队伍”，保证队伍里的元素总是按照一定的顺序排列。

2. 优先队列（Priority Queue）
比喻：想象你去排队乘坐电梯，但这个电梯是按优先级来放人的。VIP客户、老年人、孕妇都有更高的优先级，会比普通人先进入电梯。

操作：每次来一个新的人（元素），电梯会根据他/她的优先级决定是否允许进入电梯。而当电梯到达目标楼层时，优先级最高的人（比如VIP）会先下电梯。

应用：优先队列通常用来处理任务调度、任务优先级等问题，根据优先级高低处理元素。

比喻总结：优先队列像是一个按优先级排序的电梯，优先级高的人会先上车、先下车。

3. 单调栈（Monotonic Stack）
比喻：想象你有一个篮子，里面放着不同大小的苹果。每次放一个新的苹果时，你要保持篮子里的苹果从大到小或者从小到大排列。

操作：每当你放一个新的苹果（数字）时，如果当前苹果比篮子里最上面的苹果大（或小），你会先把上面的苹果拿出来（就不放回去了），直到新苹果能顺利放进去。最后，你的篮子就会按照单调顺序排列。

应用：比如“下一个更大元素”问题，栈帮助你找到每个元素的“下一个更大值”。

比喻总结：单调栈像是一个“按照大小顺序放苹果的篮子”，每次放入新苹果时，篮子里的顺序会自动调整，保证篮子里是单调的。